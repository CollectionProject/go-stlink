package main

import (
	"encoding/json"
	"flag"
	"html/template"
	"net/http"
	"os"
	"time"

	stlink "github.com/rikvdh/go-stlink"
)

var (
	ofile         = flag.String("outputfile", "targets_gen.go", "output file")
	url           = flag.String("url", "http://www.st.com/content/st_com/en/products/microcontrollers/stm32-32-bit-arm-cortex-mcus.product-grid.html/SC1169.json", "URL where the json-file comes from")
	neededColumns = map[string]string{
		"Part Number":         "type",
		"Core":                "core",
		"Operating Frequency": "freq",
		"FLASH Size":          "flash_size",
		"Data E2PROM":         "eeprom_size",
		"Internal RAM Size":   "sram_size",
	}
	colMapping = map[string]string{}

	packageTemplate = template.Must(template.New("").Parse(`// go generate
// GENERATED BY THE COMMAND ABOVE; DO NOT EDIT
// Generated at {{ .Timestamp }}
// using data from {{ .URL }}
package stlink

var stmChips = []Target{
{{- range .Targets }}
	{
		Type:       "{{ printf "%s" .Type }}",
		Core:       "{{ printf "%s" .Core }}",
		Frequency:  "{{ printf "%s" .Frequency }}",
		FlashSize:  "{{ printf "%s" .FlashSize }}",
		EepromSize: "{{ printf "%s" .EepromSize }}",
		SramSize:   "{{ printf "%s" .SramSize }}",
	},
{{- end }}
}
`))
)

type (
	column struct {
		ID                  string
		Description         string
		Name                string
		Type                string
		Order               string
		Show                bool
		Identifier          string
		QualifierIdentifier string `json:"qualifierIdentifier"`
	}

	cell struct {
		ColumnID string `json:"columnId"`
		Value    string
	}

	row struct {
		ProductID                   string `json:"productId"`
		Path                        string
		SecondaryPaths              []string `json:"secondaryPaths"`
		Cells                       []cell
		ProductFolderURL            string `json:"productFolderUrl"`
		AvailableInDistributorStock bool   `json:"availableInDistributorStock"`
		AvailableAsFreeSample       bool   `json:"availableAsFreeSample"`
		NewProductIntroduction      bool   `json:"newProductIntroduction"`
	}

	mainBody struct {
		Columns []column
		Rows    []row
	}
)

func main() {
	flag.Parse()
	rep, err := http.Get(*url)
	if err != nil {
		panic(err)
	}
	if rep.StatusCode != 200 {
		panic(err)
	}
	var dat mainBody
	if err := json.NewDecoder(rep.Body).Decode(&dat); err != nil {
		panic(err)
	}
	for _, col := range dat.Columns {
		for neededCol, name := range neededColumns {
			if col.Name == neededCol {
				colMapping[col.ID] = name
			}
		}
	}
	var targets []stlink.Target
	for _, dev := range dat.Rows {
		target := stlink.Target{}
		for _, devProp := range dev.Cells {
			t, ok := colMapping[devProp.ColumnID]
			if ok {
				switch t {
				case "type":
					target.Type = devProp.Value
				case "core":
					target.Core = devProp.Value
				case "freq":
					target.Frequency = devProp.Value
				case "flash_size":
					target.FlashSize = devProp.Value
				case "eeprom_size":
					target.EepromSize = devProp.Value
				case "sram_size":
					target.SramSize = devProp.Value
				}
			}
		}
		targets = append(targets, target)
	}
	w := os.Stdout
	var f *os.File
	if *ofile != "" {
		var err error
		f, err = os.Create(*ofile)
		if err != nil {
			panic(err)
		}
		w = f
	}
	packageTemplate.Execute(w, struct {
		Timestamp time.Time
		URL       string
		Targets   []stlink.Target
	}{
		Timestamp: time.Now(),
		URL:       *url,
		Targets:   targets,
	})
	if f != nil {
		f.Close()
	}
	//
}
