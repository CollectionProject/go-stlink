package main

import (
	"encoding/json"
	"flag"
	"net/http"
	"os"
	"strconv"
	"text/template"
	"time"

	"github.com/Sirupsen/logrus"
	"github.com/rikvdh/go-stlink"
)

var (
	ofile         = flag.String("outputfile", "targets_gen.go", "output file")
	urlPartlist   = flag.String("url", "http://www.st.com/content/st_com/en/products/microcontrollers/stm32-32-bit-arm-cortex-mcus.product-grid.html/SC1169.json", "URL where the json-file comes from")
	neededColumns = map[string]string{
		"Part Number":         "type",
		"Core":                "core",
		"Operating Frequency": "freq",
		"FLASH Size":          "flash_size",
		"Data E2PROM":         "eeprom_size",
		"Internal RAM Size":   "sram_size",
	}
	colMapping = map[string]string{}

	packageTemplate = template.Must(template.New("").Parse(`// go generate
// GENERATED BY THE COMMAND ABOVE; DO NOT EDIT
// Generated at {{ .Timestamp }}
// using data from {{ .URL }}
package stlink

var stmChips = map[CortexMPartNumber][]Target{
{{ range $core, $targets := .Targets }}	{{ $core }}: {
{{ range $i, $target := $targets }}		{ Type: "{{ $target.Type }}", Frequency: {{ $target.Frequency }}, FlashSize: {{ $target.FlashSize }}, EepromSize: {{ $target.EepromSize }}, SramSize: {{ $target.SramSize }} },
{{ end }}	},
{{ end }}
}
`))
)

type (
	column struct {
		ID                  string
		Description         string
		Name                string
		Type                string
		Order               string
		Show                bool
		Identifier          string
		QualifierIdentifier string `json:"qualifierIdentifier"`
	}

	cell struct {
		ColumnID string `json:"columnId"`
		Value    string
	}

	row struct {
		ProductID                   string `json:"productId"`
		Path                        string
		SecondaryPaths              []string `json:"secondaryPaths"`
		Cells                       []cell
		ProductFolderURL            string `json:"productFolderUrl"`
		AvailableInDistributorStock bool   `json:"availableInDistributorStock"`
		AvailableAsFreeSample       bool   `json:"availableAsFreeSample"`
		NewProductIntroduction      bool   `json:"newProductIntroduction"`
	}

	mainBody struct {
		Columns []column
		Rows    []row
	}
)

func cortexMPartNumberConstString(c stlink.CortexMPartNumber) string {
	switch c {
	case stlink.CortexMPartNumberM0:
		return "CortexMPartNumberM0"
	case stlink.CortexMPartNumberM0Plus:
		return "CortexMPartNumberM0Plus"
	case stlink.CortexMPartNumberM1:
		return "CortexMPartNumberM1"
	case stlink.CortexMPartNumberM3:
		return "CortexMPartNumberM3"
	case stlink.CortexMPartNumberM4:
		return "CortexMPartNumberM4"
	case stlink.CortexMPartNumberM7:
		return "CortexMPartNumberM7"
	}
	logrus.Warnf("Unknown Cortex-M pn: 0x%03x", c)
	return "CortexMPartNumberUnknown"
}

func cortexMStringToPartNumber(s string) stlink.CortexMPartNumber {
	switch s {
	case "ARM Cortex-M0":
		return stlink.CortexMPartNumberM0
	case "ARM Cortex-M0+":
		return stlink.CortexMPartNumberM0Plus
	case "ARM Cortex-M1":
		return stlink.CortexMPartNumberM1
	case "ARM Cortex-M3":
		return stlink.CortexMPartNumberM3
	case "ARM Cortex-M4":
		return stlink.CortexMPartNumberM4
	case "ARM Cortex-M7":
		return stlink.CortexMPartNumberM7
	}
	logrus.Warnf("Unknown Cortex-M part number: '%s'", s)
	return stlink.CortexMPartNumberUnknown
}

func main() {
	flag.Parse()
	rep, err := http.Get(*urlPartlist)
	if err != nil {
		panic(err)
	}
	if rep.StatusCode != 200 {
		panic(err)
	}
	var dat mainBody
	if err := json.NewDecoder(rep.Body).Decode(&dat); err != nil {
		panic(err)
	}
	for _, col := range dat.Columns {
		for neededCol, name := range neededColumns {
			if col.Name == neededCol {
				colMapping[col.ID] = name
			}
		}
	}
	targets := map[string][]stlink.Target{}
	for _, dev := range dat.Rows {
		target := stlink.Target{}
		core := false
		for _, devProp := range dev.Cells {
			t, ok := colMapping[devProp.ColumnID]
			if ok {
				switch t {
				case "type":
					target.Type = devProp.Value
				case "core":
					target.Core = cortexMStringToPartNumber(devProp.Value)
					core = true
				case "freq":
					x, _ := strconv.ParseUint(devProp.Value, 10, 32)
					target.Frequency = uint(x)
				case "flash_size":
					x, _ := strconv.ParseUint(devProp.Value, 10, 32)
					target.FlashSize = uint(x)
				case "eeprom_size":
					x, _ := strconv.ParseUint(devProp.Value, 10, 32)
					target.EepromSize = uint(x)
				case "sram_size":
					x, _ := strconv.ParseUint(devProp.Value, 10, 32)
					target.SramSize = uint(x)
				}
			}
		}
		if core {
			pn := cortexMPartNumberConstString(target.Core)
			targets[pn] = append(targets[pn], target)
		} else {
			logrus.Warnf("missing core for: %s", target.Type)
		}
	}
	w := os.Stdout
	var f *os.File
	if *ofile != "" {
		var err error
		f, err = os.Create(*ofile)
		if err != nil {
			panic(err)
		}
		w = f
	}
	packageTemplate.Execute(w, struct {
		Timestamp time.Time
		URL       string
		Targets   map[string][]stlink.Target
	}{
		Timestamp: time.Now(),
		URL:       *urlPartlist,
		Targets:   targets,
	})
	if f != nil {
		f.Close()
	}
	//
}
