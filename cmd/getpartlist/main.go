package main

import (
	"encoding/json"
	"flag"
	"net/http"
	"os"
	"strconv"
	"text/template"
	"time"

	"github.com/rikvdh/go-stlink"
)

var (
	ofile         = flag.String("outputfile", "targets_gen.go", "output file")
	urlPartlist   = flag.String("url", "http://www.st.com/content/st_com/en/products/microcontrollers/stm32-32-bit-arm-cortex-mcus.product-grid.html/SC1169.json", "URL where the json-file comes from")
	neededColumns = map[string]string{
		"Part Number":         "type",
		"Core":                "core",
		"Operating Frequency": "freq",
		"FLASH Size":          "flash_size",
		"Data E2PROM":         "eeprom_size",
		"Internal RAM Size":   "sram_size",
	}
	colMapping = map[string]string{}

	packageTemplate = template.Must(template.New("").Parse(`// go generate
// GENERATED BY THE COMMAND ABOVE; DO NOT EDIT
// Generated at {{ .Timestamp }}
// using data from {{ .URL }}
package stlink

var stmChips = map[CortexMPartNumber][]Target{
{{ range $core, $targets := .Targets }}
	{{ $core }}: {
{{ range $i, $target := $targets }}
		{
			Type:       "{{ $target.Type }}",
			Core:       "{{ $target.Core }}",
			Frequency:  {{ $target.Frequency }},
			FlashSize:  {{ $target.FlashSize }},
			EepromSize: {{ $target.EepromSize }},
			SramSize:   {{ $target.SramSize }},
		},
{{ end }}
	},
{{ end }}
}
`))
)

type (
	column struct {
		ID                  string
		Description         string
		Name                string
		Type                string
		Order               string
		Show                bool
		Identifier          string
		QualifierIdentifier string `json:"qualifierIdentifier"`
	}

	cell struct {
		ColumnID string `json:"columnId"`
		Value    string
	}

	row struct {
		ProductID                   string `json:"productId"`
		Path                        string
		SecondaryPaths              []string `json:"secondaryPaths"`
		Cells                       []cell
		ProductFolderURL            string `json:"productFolderUrl"`
		AvailableInDistributorStock bool   `json:"availableInDistributorStock"`
		AvailableAsFreeSample       bool   `json:"availableAsFreeSample"`
		NewProductIntroduction      bool   `json:"newProductIntroduction"`
	}

	mainBody struct {
		Columns []column
		Rows    []row
	}
)

func main() {
	flag.Parse()
	rep, err := http.Get(*urlPartlist)
	if err != nil {
		panic(err)
	}
	if rep.StatusCode != 200 {
		panic(err)
	}
	var dat mainBody
	if err := json.NewDecoder(rep.Body).Decode(&dat); err != nil {
		panic(err)
	}
	for _, col := range dat.Columns {
		for neededCol, name := range neededColumns {
			if col.Name == neededCol {
				colMapping[col.ID] = name
			}
		}
	}
	targets := map[string][]stlink.Target{}
	for _, dev := range dat.Rows {
		target := stlink.Target{}
		for _, devProp := range dev.Cells {
			t, ok := colMapping[devProp.ColumnID]
			if ok {
				switch t {
				case "type":
					target.Type = devProp.Value
				case "core":
					target.Core = devProp.Value
				case "freq":
					x, _ := strconv.ParseUint(devProp.Value, 10, 32)
					target.Frequency = uint(x)
				case "flash_size":
					x, _ := strconv.ParseUint(devProp.Value, 10, 32)
					target.FlashSize = uint(x)
				case "eeprom_size":
					x, _ := strconv.ParseUint(devProp.Value, 10, 32)
					target.EepromSize = uint(x)
				case "sram_size":
					x, _ := strconv.ParseUint(devProp.Value, 10, 32)
					target.SramSize = uint(x)
				}
			}
		}
		pn := stlink.CortexMStringToPartNumber(target.Core).ConstString()
		targets[pn] = append(targets[pn], target)
	}
	w := os.Stdout
	var f *os.File
	if *ofile != "" {
		var err error
		f, err = os.Create(*ofile)
		if err != nil {
			panic(err)
		}
		w = f
	}
	packageTemplate.Execute(w, struct {
		Timestamp time.Time
		URL       string
		Targets   map[string][]stlink.Target
	}{
		Timestamp: time.Now(),
		URL:       *urlPartlist,
		Targets:   targets,
	})
	if f != nil {
		f.Close()
	}
	//
}
